---
layout: post
title: Docker 란? (2)
categories: ['docker']
origins: ['https://www.udemy.com/course/docker-kubernetes-2022/']
published: true
---

# 도커 주요 명령어

자세한 도커 명령어에 대한 설명은 `docker [명령어] --help` 으로 알 수 있다.

## 컨테이너 목록 보기

```
docker ps
```

-   실행 중인 컨테이너 목록을 볼 수 있다.
-   `-a` 옵션을 주면 실행 중이지 않은 컨테이너도 모두 볼 수 있다.

## 이미지로부터 컨테이너 생성 및 실행하기

```
docker run [이미지]
```

## 중지된 컨테이너 다시 시작하기

```
docker start [컨테이너 ID 또는 NAME]
```

### run 과 start 의 차이

새로 컨테이너를 생성하고 실행하는 `run` 과
이미 만들어진 컨테이너를 실행하는 `start` 는 이런 특징 외에도 한가지 차이점이 더 있다.

지난 포스팅에서 빌드한 이미지를 다시 `run` 해보자.

[ ![](/assets/images/docker/docker16.png) ](/assets/images/docker/docker16.png)

`run` 을 실행한 이후에 커서가 발생하긴 하지만 cmd 에 명령을 입력할 수 없는 상태가 되었다.<br>
터미널이 차단되고, 3000 포트에 실행되고 있는 프로세스의 출력을 수신받는 상태가 된 것이다.<br>
즉, 3000 포트 프로세스에서 출력되는 콘솔과 같은 로그들을 확인할 수 있다.

**입력**은 되지 않고 **출력** 만 수신 받는 상태,<br>
이것을 **attached(연결) 모드** 라고 한다.

[ ![](/assets/images/docker/docker17.png) ](/assets/images/docker/docker17.png)

또 다른 터미널을 열고 `docker ps` 로 확인해보면 실제로 컨테이너가 실행되고 있고, `run` 직후의 터미널만 차단된 상태가 되었다.

실행시킨 컨테이너를 `stop` 명령어로 종료하고 컨테이너를 `start` 명령어로 실행해보자.

[ ![](/assets/images/docker/docker18-1.png) ](/assets/images/docker/docker18-1.png)

`run` 과 달리 터미널이 차단되지 않고 커서가 활성화 되며 터미널에 명령을 입력할 수 있는 상태가 된 것을 볼 수 있다.

[ ![](/assets/images/docker/docker19.png) ](/assets/images/docker/docker19.png)

`run` 처럼 프로세스의 출력을 수신할 수 있는 상태가 아니라 마치 프로세스가 종료된 것처럼 느껴지지만, `docker ps` 로 확인해보면 백그라운드에서 컨테이너가 실행 중인 것을 알 수 있다.

터미널이 차단되지 않고 프로세스의 출력을 수신할 수 없는 상태,<br>
이것을 **detached(분리) 모드** 라고 한다.

`docker start` 는 **detached(분리) 모드** 가 default 이고,<br>
`docker run` 은 **attached(연결) 모드** 가 default 이다. <br>

이것이 `start` 와 `run` 의 또다른 대표적인 차이점이다.

#### docker run -d

`docker run` 은 attached 모드가 default 일 뿐, detached 모드가 안되는 것은 아니다.<br>
이미지 앞에 `-d` 플래그를 주면 `run` 도 detached 모드로 실행할 수 있다.

[ ![](/assets/images/docker/docker20-1.png) ](/assets/images/docker/docker20-1.png)

#### docker start -a

`docker start` 는 detached 모드가 default 일 뿐, attached 모드가 안되는 것은 아니다.<br>
이미지 앞에 `-a` 플래그를 주면 `start` 도 attached 모드로 실행할 수 있다.

[ ![](/assets/images/docker/docker23.png) ](/assets/images/docker/docker23.png)

#### docker attach

detached 모드로 실행된 컨테이너를 다시 attached 모드로 볼 수도 있다.<br>
`docker attach [컨테이너 NAME 또는 ID]` 명령어로 백그라운드에서 실행되고 있는 컨테이너를 다시 attached 모드로 확인할 수 있다.

[ ![](/assets/images/docker/docker21.png) ](/assets/images/docker/docker21.png)

#### docker logs

또다른 명령어로는 `docker logs` 가 있다.<br>
리눅스의 `tail` 명령어와 같다고 생각하면 된다.<br>
`docker logs [컨테이너 NAME 또는 ID]` 으로 백그라운드에서 실행 중인 컨테이너의 출력 결과를 단발적으로 확인할 수 있다.

리눅스 `tail` 의 `-f` 명령어처럼,<br>
`docker logs` 도 `-f` 옵션을 추가하면 수신을 유지하여 연속적인 출력 결과를 볼 수 있다. <br>
즉, attached 모드가 된다.

[ ![](/assets/images/docker/docker22-1.png) ](/assets/images/docker/docker22-1.png)

#### docker run -it

```
docker run -it [이미지]
```

`run` 은 default 로 attached 모드가 된다고 했다.<br>
이는 출력만 수신 받을 뿐, 입력은 되지 않는 상태를 의미하는데, <br>
`-i` 옵션을 주면 interactive, 즉, 입력도 가능한 상태가 된다.

일반적으로 `-i` 옵션은 `-t` 옵션과 함께 사용한다.<br>
`-t` 는 TTY 라는 뜻으로 터미널, 콘솔을 뜻한다.<br>
즉, 입력을 터미널 모드로 받겠다는 의미이다.

#### docker start -a -i

```
docker start -a -it [컨테이너 NAME 또는 ID]
```

`docker start -a` 은 `start` 를 attached 모드로 볼 수 있는 상태라고 했다.<br>
이는 출력만 수신 받을 뿐, 입력은 되지 않는 상태를 의미하는데, <br>
`-i` 옵션을 주면 interactive, 즉, 입력도 가능한 상태가 된다.<br>
이 역시 `-t` 옵션과 함께 사용되는 편이다.

만약 `run` 때 `-t` 옵션을 사용했었다면 컨테이너를 생성할 때 `-t` 옵션을 기억해 다시 써줄 필요 없다.
